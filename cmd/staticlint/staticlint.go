// staticlint is a tool that provides various code analysis checks for Go code.
//
// Launch Mechanism:
//
// staticlint uses the multichecker package from the go/analysis library
// to run multiple analyzers on the provided Go code.
// The specific analyzers to be executed by staticlint are determined
// by a configuration file named 'config.json'. This file must be
// located in the same directory as the staticlint executable.
//
// The configuration file specifies which staticcheck analyzers to run,
// and staticlint runs these in addition to its built-in analyzers.
//
// Built-in Analyzers:
//
// - OsExitAnalyzer: Prohibits the use of a direct call to os.Exit in the main function.
// - printf.Analyzer: Checks for incorrect usage of formatting functions.
// - shadow.Analyzer: Checks for variable shadowing.
// - structtag.Analyzer: Checks for ill-formed struct field tags.
// - shift.Analyzer: Checks for suspicious bit shifts.
// - errcheck.Analyzer: Checks for unchecked errors.
//
// In addition to the built-in analyzers, staticlint can also run
// any of the analyzers from the staticcheck tool, as specified in
// the configuration file.
package main

import (
	"encoding/json"
	"go/ast"
	"os"
	"path/filepath"
	"strings"

	"github.com/kisielk/errcheck/errcheck"
	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/multichecker"
	"golang.org/x/tools/go/analysis/passes/printf"
	"golang.org/x/tools/go/analysis/passes/shadow"
	"golang.org/x/tools/go/analysis/passes/shift"
	"golang.org/x/tools/go/analysis/passes/structtag"
	"honnef.co/go/tools/staticcheck"
)

// OsExitAnalyzer is an analyzer that prohibits the use of a direct call to os.Exit
// in the main function of the main package.
var OsExitAnalyzer = &analysis.Analyzer{
	Name: "osExit",
	Doc:  "Prohibits the use of a direct call to os.Exit in the main function",
	Run:  checkOsExit,
}

// checkOsExit is the function that implements the logic for the OsExitAnalyzer.
// It traverses the AST of the provided files and reports any direct calls to os.Exit
// within the main function of the main package.
func checkOsExit(pass *analysis.Pass) (interface{}, error) {
	// If it's not the main package, just return
	if pass.Pkg.Name() != "main" {
		return nil, nil
	}

	for _, file := range pass.Files {
		if len(file.Comments) > 0 && strings.Contains(file.Comments[0].Text(), "Code generated by 'go test'. DO NOT EDIT.") {
			continue
		}

		ast.Inspect(file, func(node ast.Node) bool {
			if fn, ok := node.(*ast.FuncDecl); ok && fn.Name.Name == "main" {
				ast.Inspect(node, func(n ast.Node) bool {
					if call, ok := n.(*ast.CallExpr); ok {
						sel, ok := call.Fun.(*ast.SelectorExpr)
						if ok && isOsExit(sel) {
							pass.Reportf(call.Pos(), "direct call to os.Exit found in main function")
						}
					}
					return true
				})
			}
			return true
		})
	}
	return nil, nil
}

// isOsExit checks if the provided selector expression is a call to os.Exit.
func isOsExit(sel *ast.SelectorExpr) bool {
	ident, ok := sel.X.(*ast.Ident)
	return ok && ident.Name == "os" && sel.Sel.Name == "Exit"
}

// Config is the name of the configuration file that the main function reads to determine
// which staticcheck analyzers to run.
const Config = `config.json`

type ConfigData struct {
	Staticcheck []string
}

// main is the entry point of the application. It reads the configuration file, sets up
// the list of analyzers to run, and then runs them using multichecker.
func main() {
	appfile, err := os.Executable()
	if err != nil {
		panic(err)
	}

	data, err := os.ReadFile(filepath.Join(filepath.Dir(appfile), Config))
	if err != nil {
		panic(err)
	}

	var cfg ConfigData
	if err = json.Unmarshal(data, &cfg); err != nil {
		panic(err)
	}

	mychecks := []*analysis.Analyzer{
		printf.Analyzer,
		shadow.Analyzer,
		structtag.Analyzer,
		shift.Analyzer,
		OsExitAnalyzer,
		errcheck.Analyzer,
	}

	checks := make(map[string]bool)

	for _, v := range cfg.Staticcheck {
		checks[v] = true
	}

	for _, v := range staticcheck.Analyzers {
		if strings.HasPrefix(v.Analyzer.Name, "SA") {
			mychecks = append(mychecks, v.Analyzer)
		}
	}

	multichecker.Main(
		mychecks...,
	)
}
